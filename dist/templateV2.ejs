/* This file was generated by https://github.com/dested/serverless-client-builder */
/* tslint:disable */
/* eslint-disable */
import {ClientTransformOptions,ClientOptions,ClientSocketOptions,ControllerOptions} from './baseClient';
declare type ObjectId = string;

<% for(const controller of controllers) { %>
    <% const name = controller.controllerName.replace(/(\-\w)/g, (m) => m[1].toUpperCase()).replace(/^\w/, c => c.toUpperCase()) %>
    export class <%= name %>Client  {


    <% if(controller.websocketFunctions.length + controller.websocketEvents.length > 0){ %>
         socket?: WebSocket;
         events?: <%= name %>Events;
         connect(events: <%= name %>Events) {
            this.events=events;
        this.socket = new WebSocket(ClientSocketOptions.baseUrl);
        this.socket.onmessage = message => {
            if(!this.events)return;
        const response=JSON.parse(message.data);
        switch(response.event){
        <% for(const ev of controller.websocketEvents) { %>
            case '<%= ev.route %>':
            this.events.<%= ev.name.replace('send', 'on') %> && this.events.<%= ev.name.replace('send', 'on') %>(response.data);
            break;
        <% } %>
        }
        };
        this.socket.onclose = e => {
        this.events?.onDisconnect && this.events?.onDisconnect();
        };
        this.socket.onopen = () => {
        this.events?.onConnect && this.events?.onConnect();
        };
        }
         disconnect(){
        this.socket && this.socket.close();
        }
    <% } %>
    <% for(const func of controller.websocketFunctions) { %>
         <%= func.name %>(request: <%= func.requestType %>): void {
        this.socket && this.socket.send(
        JSON.stringify({
        action: '<%= func.route %>',
        jwt:ClientSocketOptions.getJwt(),
        data: request,
        })
        );
        }
    <% } %>

    <% for(const func of controller.functions) { %>
        static async <%= func.name %>
        <TPromise=<%= func.returnType %>>(<%= func.requestType === 'void' ? '' : `model: ${func.requestType}` %>,handle:<%= func.handleType %>) :Promise<TPromise|undefined>{

        let url = ClientOptions.baseUrl + '<%= func.url %>?';
        <% for(let u = 0;u < func.urlReplaces.length;u++) { %>
            url = url.replace(':<%= func.urlReplaces[u] %>',model.<%= func.urlReplaces[u] %>)
            .replace('{<%= func.urlReplaces[u] %>}',model.<%= func.urlReplaces[u] %>);
        <% } %>

            return make<%=func.method.toUpperCase() === 'GET'?'Get':''%>Request(url,model,'<%=func.method.toUpperCase()%>',handle);
        }

    <% } %>

    }

    <% if(controller.websocketFunctions.length + controller.websocketEvents.length > 0){ %>
        export interface <%= name %>Events{
        <% for(const ev of controller.websocketEvents) { %>
            <%= ev.name.replace('send', 'on') %>:(req:<%= ev.requestType %>)=>void;
        <% } %>
        onDisconnect:()=>void;
        onConnect:()=>void;
        }
    <% } %>

<% } %>

<% for(const interface of interfaces) { %>
    <%= interface %>
<% } %>

      async function handleResponse(responseText: string, status: number, handle: any) {
        try {
          if (handle[status]) {
            const val = responseText === '' ? null : JSON.parse(responseText);
            await handle[status](val);
            return undefined;
          } else {
            switch (status) {
              case 200: {
                return JSON.parse(responseText);
              }
              case 401: {
                ClientOptions.handleUnauthorized(responseText);
                break;
              }
              case 500: {
                const body = JSON.parse(responseText);
                ClientOptions.handleError(body.error || responseText);
                break;
              }
            }
          }
        } catch (ex) {
          if (!handle[500]) {
            ClientOptions.handleError(ex.toString());
          } else {
            await handle[500](ex.toString());
          }
        }
      }
   async function makeRequest(url:string,model:any,method:string, handle: any) {
try{
const options = {
method,
} as RequestInit;

        options.body = JSON.stringify(model);

const response = await fetch(url,   ClientTransformOptions(options));
const status = response.status;
const responseText = await response.text();
return handleResponse(responseText,status,handle);
}catch(ex){
return handleResponse(ex.toString(),500,handle);

}}



   async function makeGetRequest(url:string,model:any,method:string, handle: any) {
try{
const options = {
method,
} as RequestInit;
        url += Object.keys(model)
        .filter(key => !!(model as any)[key])
        .map(key => `${key}=${encodeURIComponent((model as any)[key])}`)
        .join('&');

const response = await fetch(url,   ClientTransformOptions(options));
const status = response.status;
const responseText = await response.text();
return handleResponse(responseText,status,handle);
}catch(ex){
return handleResponse(ex.toString(),500,handle);

}}


