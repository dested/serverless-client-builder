/* This file was generated by https://github.com/dested/serverless-client-builder */
/* tslint:disable */
import {BaseClient} from './baseClient';

<% for(const controller of controllers) { %>
    <%const name=controller.controllerName.replace(/(\-\w)/g, (m)=>m[1].toUpperCase()).replace(/^\w/, c => c.toUpperCase())%>
    export class <%=name%>Client extends BaseClient {
    constructor(getJwt:()=>string){
    super(getJwt);
    }

    <%if(controller.websocketFunctions.length+controller.websocketEvents.length>0){%>
    private socket: WebSocket;
    connect(events: <%=name%>Events) {
    this.socket = new WebSocket(this.websocketUrl);
    this.socket.onmessage = message => {
    const response=JSON.parse(message.data);
    switch(response.event){
    <% for(const ev of controller.websocketEvents) { %>
    case '<%=ev.route%>':
    events.<%=ev.name.replace('send','on')%> && events.<%=ev.name.replace('send','on')%>(response.data);
    break;
    <%}%>
    }
    console.log(message.data);
    };
    this.socket.onclose = e => {
    console.log(e);
    events.onDisconnect && events.onDisconnect();
    };
    this.socket.onopen = e => {
    console.log(e);
    events.onConnect && events.onConnect();
    };
    }
    disconnect(){
    this.socket && this.socket.close();
    }
    <%}%>
    <% for(const func of controller.websocketFunctions) { %>
    <%=func.name%>(request: <%=func.requestType%>): void {
    this.socket && this.socket.send(
    JSON.stringify({
    action: '<%=func.route%>',
    jwt:this.getJwt(),
    data: request,
    })
    );
    }
    <% } %>

    <% for(const func of controller.functions) { %>
        async <%= func.name %><TPromise=<%= func.returnType %>>(<%= func.requestType==='void'?'':`model: ${func.requestType}`%>,handle:<%=func.handleType%>) :Promise<TPromise>{
    try{
    let url = this.baseUrl + '<%= func.url %>?';

    const options = {
    method: "<%= func.method%>",
    headers: {
    "Content-Type": "application/json",
    "Accept": "application/json"
    }
    } as RequestInit;
    <% if(func.requestType!=='void') {%>
        <% if(func.method.toUpperCase()==='GET') {%>
            url += Object.keys(model)
            .filter(key => !!(model as any)[key])
            <% for(let u=0;u<func.urlReplaces.length;u++) {%>
            .filter(key => key!=='<%=func.urlReplaces[u]%>')
            <% } %>
            .map(key => `${key}=${encodeURIComponent((model as any)[key])}`)
            .join('&');
        <% } else {%>
            options.body = JSON.stringify(model);
        <% } %>
    <% } %>

    <% for(let u=0;u<func.urlReplaces.length;u++) {%>
    url = url.replace('{<%=func.urlReplaces[u]%>}',model.<%=func.urlReplaces[u]%>);
    <% } %>

    const response = await fetch(url, await this.transformOptions(options));

    const status = response.status;
    const headers: any = {};

    if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => headers[k] = v); };

    const responseText = await response.text();

    if (status === 200) {
    if(handle[200]){
    return await handle[200](responseText === "" ? null : JSON.parse(responseText));
    }
    return JSON.parse(responseText)
    }
    <%=func.errorCode.map(a=>`else if (status === ${a}) {
            await handle[${a}](responseText === "" ? null : JSON.parse(responseText));
        }`).join('')%>
    else {
    await handle[500](responseText);
    }
    }catch(ex){
    await handle[500](ex.toString());
    }
    }
    <% } %>

    }


    <%if(controller.websocketFunctions.length+controller.websocketEvents.length>0){%>
    export interface <%=name%>Events{
    <% for(const ev of controller.websocketEvents) { %><%=ev.name.replace('send','on')%>?:(req:<%=ev.requestType%>)=>void;<%}%>onDisconnect?:()=>void;onConnect?:()=>void;
    }
    <%}%>

    <% } %>



    <% for(const interface of interfaces) { %>
        <%= interface %>
    <% } %>
