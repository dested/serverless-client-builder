import * as ejs from 'ejs';
import * as fs from 'fs';
import * as prettier from 'prettier';
import Project, {MethodDeclaration, SyntaxKind, ts} from 'ts-simple-ast';
import {ManageSymbols} from './manageSymbols';

export function processFile(apiPath: string, outputFile: string) {
  const extendedUrl = true;

  const tsConfigFilePath = apiPath + 'tsconfig.json';

  const project = new Project({
    tsConfigFilePath,
  });

  const symbolManager = new ManageSymbols();
  const controllerDataItems: ControllerData[] = [];
  for (const sourceFile of project.getSourceFiles()) {
    for (const classDeclaration of sourceFile.getDescendantsOfKind(SyntaxKind.ClassDeclaration)) {
      if (
        classDeclaration.getDecorators().length > 0 &&
        classDeclaration.getDecorators()[0].getName() === 'controller'
      ) {
        const controllerName = classDeclaration
          .getDecorators()[0]
          .getArguments()[0]
          .getText();

        const controllerData: ControllerData = {name: eval(controllerName), methods: [], events: []};
        controllerDataItems.push(controllerData);
        for (const declaration of classDeclaration.getMethods()) {
          if (declaration.getDecorator('request')) {
            const name = declaration.getName();
            const decorator = declaration.getDecorator('request');
            const method = eval(decorator.getArguments()[0].getText());
            const path = eval(decorator.getArguments()[1].getText());
            const options: {key: string; value: string}[] = [];
            if (decorator.getArguments()[2]) {
              const text = decorator.getArguments()[2].getText();
              const requestOptions = eval('(' + text + ')');
              if (requestOptions) {
                for (const key of Object.keys(requestOptions)) {
                  options.push({key, value: requestOptions[key]});
                }
              }
            }
            controllerData.methods.push({
              controllerName: controllerData.name,
              name,
              method,
              path,
              options,
              declaration,
            });
          }
          if (declaration.getDecorator('event')) {
            const methodName = declaration.getName();
            const decorator = declaration.getDecorator('event');
            const rate = eval(decorator.getArguments()[0].getText());
            controllerData.events.push({
              controllerName: controllerData.name,
              name: methodName,
              rate,
              declaration,
            });
          }
        }
      }
    }
  }

  const header = fs.readFileSync(apiPath + 'serverless-header.yml', {encoding: 'utf8'});
  let bottom = '';
  for (const controllerDataItem of controllerDataItems) {
    for (const method of controllerDataItem.methods) {
      bottom += `
  ${controllerDataItem.name}_${method.name}:
    handler: handler.${controllerDataItem.name}_${method.name}
    ${method.options.map(a => `${a.key}: ${a.value}`).join('\r\n    ')}
    events:
      - http:
          path: ${extendedUrl ? `${controllerDataItem.name}/` : ''}${method.path}
          method: ${method.method}
          cors: true`;
    }
    for (const event of controllerDataItem.events) {
      bottom += `
  ${event.name}:
    handler: handler.${controllerDataItem.name}_${event.name}
    events:
      - schedule: ${event.rate}`;
    }
  }
  const disclaimer = '# This file was generated by https://github.com/dested/serverless-client-builder\r\n';
  fs.writeFileSync(apiPath + 'serverless.yml', disclaimer + header + bottom, {encoding: 'utf8'});

  for (const controllerDataItem of controllerDataItems) {
    for (const method of controllerDataItem.methods) {
      const funcName = method.name;

      const funcNode = method.declaration;

      assert(funcNode.getParameters().length === 1, 'The export must only have one parameter');
      const eventArg = funcNode.getParameters()[0].getType();
      assert(eventArg.getSymbol().getName() === 'RequestEvent', 'RequestEvent argument must be a generic event class');
      const typeArgument = eventArg.getTypeArguments()[0];
      let requestName: string;
      if (typeArgument.getText() !== 'void') {
        symbolManager.addSymbol(typeArgument);
        requestName = typeArgument.getSymbol().getName();
      } else {
        requestName = 'void';
      }

      const returnType = funcNode.getReturnType();
      assert(returnType.getSymbol().getName() === 'Promise', 'Return type must must be a promise');
      const returnTypeArgument = returnType.getTypeArguments()[0];
      assert(
        returnTypeArgument.getSymbol().getName() === 'HttpResponse',
        'Return type must must be a promise of HttpResponse'
      );
      const httpResponseTypeArgument = returnTypeArgument.getTypeArguments()[0];
      const httpResponseErrorArgument = returnTypeArgument.getTypeArguments()[1];

      const errorTypes: ts.Symbol[] = [];

      if ((httpResponseErrorArgument.compilerType as any).intrinsicName !== 'undefined') {
        if (httpResponseErrorArgument.getUnionTypes().length === 0) {
          errorTypes.push(httpResponseErrorArgument.getApparentType().compilerType.getSymbol());
        } else {
          for (const unionType of httpResponseErrorArgument.getUnionTypes()) {
            errorTypes.push(unionType.compilerType.getSymbol());
          }
        }
      }
      symbolManager.addSymbol(httpResponseTypeArgument);
      addFunction(
        method.controllerName,
        funcName,
        requestName,
        httpResponseTypeArgument.getSymbol().getName(),
        errorTypes,
        '/' + (extendedUrl ? `${controllerDataItem.name}/` : '') + method.path,
        method.method
      );
    }
  }
  let js = ejs.render(
    fs.readFileSync(require.resolve('./template.ejs'), {encoding: 'utf8'}),
    {
      interfaces: symbolManager.symbols.map(a => getSource(a)),
      controllers,
    },
    {escape: e => e}
  );

  const prettierFile = apiPath + '.prettierrc';
  const prettierOptions = readJson(prettierFile);
  if (prettierOptions) {
    js = prettier.format(js, prettierOptions);
  }
  // console.log(js);

  fs.writeFileSync(outputFile, js, {encoding: 'utf8'});
}

function assert(thing: boolean, error: string) {
  if (!thing) {
    throw error;
  }
}

const readJson = (path: string) => {
  if (fs.existsSync(path)) {
    return JSON.parse(fs.readFileSync(path, {encoding: 'utf8'}));
  }
  return null;
};

const controllers: {
  controllerName: string;
  functions: {
    url: string;
    method: string;
    name: string;
    requestType: string;
    returnType: string;
    errorCode: string[];
    handleType: string;
  }[];
}[] = [];

function getSourceWithoutStatusCode(a: ts.Symbol) {
  const source = getSource(a, false);
  return source.replace(/statusCode\s*:\s*\d+,?;?/g, '');
}

function addFunction(
  controllerName: string,
  name: string,
  requestType: string,
  returnType: string,
  errorTypes: ts.Symbol[],
  url: string,
  method: string
) {
  const errorCode = errorTypes.map(a => (a.members.get('statusCode' as any).valueDeclaration as any).type.literal.text);
  const handleType = `{200?:(result:${returnType})=>TPromise,500:(result:string)=>void,${errorTypes
    .map(a => {
      const statusCode = (a.members.get('statusCode' as any).valueDeclaration as any).type.literal.text;
      const source = getSourceWithoutStatusCode(a);
      return `${statusCode}:(result:${source})=>void`;
    })
    .join(',')}}`;

  let controller = controllers.find(a => a.controllerName === controllerName);
  if (!controller) {
    controller = {controllerName, functions: []};
    controllers.push(controller);
  }

  controller.functions.push({
    name,
    handleType,
    requestType,
    returnType,
    url,
    method,
    errorCode,
  });
}

function getSource(symbol: ts.Symbol, addExport: boolean = true) {
  return symbol.declarations
    .map(a => {
      let str = a.getText();
      if (addExport && str.indexOf('export') === -1) {
        str = 'export ' + str;
      }
      return str;
    })
    .join('\n');
}

export interface ControllerData {
  name: string;
  methods: ControllerMethodData[];
  events: ControllerEventData[];
}
export interface ControllerMethodData {
  controllerName: string;
  name: string;
  method: string;
  path: string;
  options: {key: string; value: string}[];
  declaration: MethodDeclaration;
}
export interface ControllerEventData {
  controllerName: string;
  name: string;
  rate: string;
  declaration: MethodDeclaration;
}
